# Elastisched
![Elastisched UI](docs/ui-preview.png)

Elastisched is a scheduling and time management software built around "blobs": flexible, schedulable blocks of time with constraints.

## Core Concepts

- Blobs represent tasks/events with a schedulable time range and optional policies (which guide the scheduler).
- Policies can make blobs overlappable, invisible, or splittable to guide scheduling behavior.
- Scheduling uses simulated annealing and preference learning to search for good local minima under constraints.

## Features

- Day, week, month, and year views
- Interactive range selection in the UI
- Configurable schedule metadata (name, subtitle, minute granularity)
- JSON-based blob storage with SQLite

## Project Layout

- `backend/elastisched_api`: FastAPI backend and models
- `src/elastisched`: core scheduling library + engine
- `frontend`: UI (HTML/CSS/JS)
- `learning`: preference learning and ML models
- `integrations`: integrations with other calendar apps, i.e., Google Calendar
- `mcp`: a FastMCP integration for elastisched
- `tests`: API and recurrence tests

## Quick Start

### Docker

1. `docker compose up --build`
2. Open `http://localhost:8000/ui`

### Local (no Docker)

1. Install dependencies.
2. Run the API.
3. Open the UI at `/ui` or open `frontend/index.html` directly.

## Troubleshooting

- If you see a GLIB/GCC mismatch in native builds, align your Conda GCC/G++ with the version used to compile the library.

## Miscellaneous

### Scheduler Algorithm
The scheduler algorithm uses simulated annealing, which is a form of stochastic optimization for often discrete, non-differentiable cost functions. 
It will not always find the global minima, but tends to find good local minima. However, for calendars with not as many events, it will find the global
minima with high probability. 

#### Lookahead
Lookahead is an important concept since it determines how many events the scheduler will have to work with at a time, affecting efficiency and solution
quality. The default is set to 2 weeks, but can be changed in settings. Whenever a blob or recurrence is added or edited, the scheduler marks the old schedule
as "dirty", prompting the user to run the scheduling algorithm.

#### Preference Learning
Apart from some the most primitive cost functions, the simulated annealer won't be able to truly capture a user's intent only through code, since 
our preferences for what a good schedule might look like depends on the user and can't simply be hard coded in. Hence, elastisched also implements
preference learning. The most primitive cost functions currently implemented are: illegal schedule cost (which may be deprecated to prevent illegal
schedules entirely via simulated annealer), overlapping event cost (reduce the amount of overlap for overlappable events), and split count cost
(reduce the amount of times that we split a splittable event). Naturally, most schedules conditioned by the simulated annealer are "optimal", which
implies there are many potential global optima and requires tie-breaking.

Preference learning helps to break ties by slowly learning the user's preferences over what schedules should be chosen when multiple global optima
exists. 

We can view the simulated annealer as a generative algorithm which generates optimal schedules. Preference learning then runs the learned cost function
against multiple samples generated by the annealer and tries to learn the following distribution: P(U(A) > U(B)), where A and B are schedules returned by the
annealer and U is some utility function implicitly learned by the preference learning model. We can then use this learned preference function to return 
the most suitable schedule in O(S) time, where S is the number of samples discovered by the simulated annealer. 

#### Semantic Preference Learning
To help the preference learning algorithm, we utilize all information about an event including the description and recurrence name. 
In the backend, we use a sentence-transformer model which can be optionally GPU accelerated if the user has a GPU. 

